##====---- appveyor.yml                                               ----====##
# CI for OpenCppCoverage.
#

# fetch repository as a zip archive
shallow_clone: true

skip_branch_with_pr: true
skip_commits:
  files:
  - .github/
  - .gitignore
  - BuildThirdPartyDependencies.bat
  - CreateRelease.bat
  - LICENSE.txt
  - '**/*.md'
  - '**/*.filters'

cache:
- C:\Tools\vcpkg\vcpkg.exe

image:
- Visual Studio 2017

platform:
- x86
- x64

environment:
  matrix:
  - BUILD: dependency-zip
  - configuration: Debug
  - configuration: Release
  #- BUILD: dependency-zip
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  #- configuration: Debug
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  #- configuration: Release
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  global:
    APPVEYOR_SAVE_CACHE_ON_ERROR: true
    TOOLCHAIN_FILE: 'C:/Tools/vcpkg/scripts/buildsystems/vcpkg.cmake'
    FREEZE_SHA1: 4c6950adcb4a442e24b43af6643720c41a80fdc8
    NUGET_version: 1.2.0

for:
-
  matrix:
    only:
    - BUILD: dependency-zip
  before_build:
  - ps: Write-Warning 'Skipping before_build.'
  build_script:
  - ps: Write-Warning 'Skipping build_script.'
  after_build:
  - ps: Write-Warning 'Skipping after_build.'
  before_test:
  - ps: Write-Warning 'Skipping before_test.'
  after_test:
  - ps: Write-Warning 'Skipping after_test.'
  test_script:
  - ps: Write-Warning 'Skipping test_script.'
  on_success:
  - ps: |
      Write-Output "Creating ${dependency_zip_name}"
      7z u -bso0 -- ${dependency_zip_name} "C:\Tools\vcpkg\installed"
      if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
        7z u -bso0 -- ${dependency_zip_name} "C:\Tools\vcpkg\packages"
      }
      if ( $archive_incomplete ) {
        New-Item archive_incomplete
        7z u -bso0 -- ${dependency_zip_name} ".\archive_incomplete"
        Warning -Message 'Dependency archive is incomplete.' -Details `
          'Not all dependencies have been build. Expect increased build times.',
          'The archive will be completed during the next build.' -NewLine
      }
      Push-AppveyorArtifact ${dependency_zip_name}


init:
# Collect AppVeyor Artifact of previously compiled dependencies.
- ps: |
    $time_limit = (Get-Date) + $(New-TimeSpan -Minutes 45)
- ps: |
    $dependency_zip_name = "dependency_${env:PLATFORM}"
    $env:redist_name = "OpenCppCoverage-${env:PLATFORM}"
    if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
      $dependency_zip_name += '_nuget'
    }
    if ( $env:DEPENDENCIES -and "${env:DEPENDENCIES}" -eq "FREEZE" ) {
      $dependency_zip_name += "_v${env:NUGET_version}"
    } else {
      $dependency_zip_name += '_HEAD'
      $env:redist_name += '_HEAD'
    }
    if ( "${env:APPVEYOR_REPO_TAG}" -eq "true" ) {
      $env:redist_name += '-'+$($env:APPVEYOR_REPO_TAG_NAME).Replace('release-','')
    }
    $dependency_zip_name += ".zip"
    Write-Output ("Artifact name: ${dependency_zip_name}`n"+`
      "Redist. name:  ${env:redist_name}`nJobID:         ${env:APPVEYOR_JOB_ID}"
    )
- ps: |
    function Send-Output {
      param([parameter(Mandatory=$true,Position=0,ValueFromPipeline=$true)]
        [alias('m')][String]$Message,
        [parameter(Position=1,ValueFromPipeline=$true,ValueFromRemainingArguments=$true)]
        [alias('d')][String[]]$Details,[alias('hide','h')][Switch]$HideDetails,
        [alias('n','NewLine')][Switch]$SeparateLines,
        [Switch]$Error,[Switch]$Warning,[Switch]$Info
      )
      if ($Details) {
        $Details = $(
          if ($SeparateLines) { $Details -join "`n" } else { $Details -join ' ' }
        ) -replace "`n [^\s]", "`n"
      }
      if ($env:APPVEYOR) { 
        $AppVeyor = 'Add-AppveyorMessage ${Message} -Category '
        if       ($Error)   { $AppVeyor += 'Error'
        } elseif ($Warning) { $AppVeyor += 'Warning'
        } else              { $AppVeyor += 'Information' }
        if ($Details) { $AppVeyor += ' -Details $Details' }
        Invoke-Expression -Command $AppVeyor
      }
      if ($Error) {
        Write-Host $Message -ForegroundColor White -BackgroundColor Red
        if ($Details -and -not $HideDetails) { Write-Host $Details -ForegroundColor Red }
        if ($env:APPVEYOR -and -not $ContinueOnError) { $Host.SetShouldExit(1) }
      } elseif ($Warning) {
        if ($Details -and -not $HideDetails) { $Message += "`n${Details}" }
        Write-Warning $Message
      } else {
        if ($Details -and -not $HideDetails) {
          $Message += "`n$("-- $Details" -replace "`n", "`n-- ")"
        }
        Write-Output "INFO: $Message"
      }
    } # /function Send-Output
    function Error   { Send-Output @Args -Error }
    function Warning { Send-Output @Args -Warning }
    function Info    { Send-Output @Args -Info }
- ps: |
    function Get-JSON {
      param([parameter(Mandatory=$true,Position=0,ValueFromPipeline=$true)]
        [String]$URI
      )
      Invoke-RestMethod "${URI}" `
        -Method Get -DisableKeepAlive -TimeoutSec 300 `
        -Headers @{ "Authorization" = "Bearer ${env:api_token}" } `
        -ContentType 'application/json'
    }
    function Select-dependency-zip-jobId {
      param(
        [parameter(Mandatory=$true,Position=0,ValueFromPipeline=$true)]$Build
      )
      if (Get-Member -InputObject $Build -Name 'build' -MemberType Properties)
      { $Build = $Build.build }
      if (Get-Member -InputObject $Build -Name 'jobs' -MemberType Properties) { 
        if (-not $Build.jobs.Count) { Warning 'Incompatible input; no jobs' `
          -Details "Build Version: $($Build.version)",
          'Possibly a build with a yml parsing error.' -n
        }
      } else { Error 'Incompatible input object' }
      $job = $Build.jobs | where { $_.artifactsCount -ge 1 -and
        $_.name -match 'Build=dependency-zip' -and $_.status -eq 'success' -and
        -not ($env:DEPENDENCIES -match 'FREEZE' -xor $_.name -match 'FREEZE') -and
        -not ($env:NUGET -match 'on' -xor $_.name -match 'NUGET=on') -and
        -not ($_.name -match 'Platform: x86' -xor $env:PLATFORM -eq 'x86') -and 
        -not ($_.name -match 'Platform: x64' -xor $env:PLATFORM -eq 'x64')
      }
      if ($job) { return $job[0].jobId }
    }
    Write-Output 'Collect previously compiled dependencies'
    $api_url = 'https://ci.appveyor.com/api'
    $url_project = "${api_url}/projects/${env:APPVEYOR_ACCOUNT_NAME}/${env:APPVEYOR_PROJECT_SLUG}"
    $url_history = "${url_project}/history?recordsNumber=20"
    if ( -not $env:api_token ) {
      Error 'AppVeyor API-token not found!' `
        -Details 'Set the environment variable "api_token" ',
        'in the AppVeyor project settings. (ðŸ”’ With variable encryption.)'
    }
    if ( $env:BUILD -and "${env:Build}" -eq "dependency-zip" ) {
      Write-Output '-- Get dependencies from previous build:'
      $URI = @( "${url_history}&branch=${env:APPVEYOR_REPO_BRANCH}" )
      if ( $env:APPVEYOR_REPO_BRANCH -ne 'master') {
        $URI += "${url_history}&branch=master"
      }
      :lbl_URI foreach ($_ in $URI) {
        $history = Get-JSON -URI "$_"
        if ($history -eq $null) { continue }
        foreach ($build in $history.builds) {
          $jobId = Get-JSON -URI "${url_project}/build/$($build.version)" |
            Select-dependency-zip-jobId
          if ($jobId -ne $null) { echo $jobId; break lbl_URI }
        }
      }
    } else {
      Write-Output '-- Get dependencies from current build:'
      $url_branch = "${url_project}/branch/${env:APPVEYOR_REPO_BRANCH}"
      $branchBuilds = Get-JSON -URI $url_branch
      if ( $branchBuilds ) {
        if ( $branchBuilds.build.buildNumber -ne $env:APPVEYOR_BUILD_NUMBER) {
          Warning 'API change: not returning current build in progress!' `
            -Details "Expected build: ${env:APPVEYOR_BUILD_NUMBER}",
            "Received build: $($branchBuilds.build.buildNumber)" -NewLine
        }
        $jobId = Select-dependency-zip-jobId $branchBuilds
      }
    }
    if ( $jobId -ne $null ) {
      $url_zip_file = "${api_url}/buildjobs/${jobId}/artifacts/${dependency_zip_name}"
      Write-Output "-- Downloading ...`n${url_zip_file}"
      $(Invoke-RestMethod "${url_zip_file}" `
        -Method Get -DisableKeepAlive -TimeoutSec 300 `
        -ContentType 'application/zip, application/octet-stream' `
        -OutFile $dependency_zip_name
        $success = $?
      )
    } else { $success = $false
      Warning 'Cannot find artifact for current configuration.'
    }
    if ( $success ) {
      Write-Output '-- Downloading ... done'
      if ([IO.File]::Exists("${pwd}\${dependency_zip_name}")) {
        Write-Output "-- Extracting ...`n${dependency_zip_name}"
        7z x -y -bso0 $dependency_zip_name -o"C:\Tools\vcpkg"
        Write-Output '-- Extracting ... done'
        if ( Test-Path 'C:\Tools\vcpkg\archive_incomplete' ) {
          $archive_incomplete = $true
          Warning 'Dependency archive is incomplete. Increased build time.'
          rm 'C:\Tools\vcpkg\archive_incomplete'
          7z d -bso0 -- ${dependency_zip_name} "archive_incomplete"
        }
      } else { Error "${pwd}\${dependency_zip_name} does not exist!" }
    } else {
      Info 'Reset previously compiled dependencies from artifact - failed' `
        -Details 'Rebuilding all dependencies'
    }

install:
# Packages to install from vcpkg:
- ps: |
    $packages = @( # Sorted to build in separate sets.
      'poco',
      'protobuf',
      'gtest',
      'ctemplate',
      'boost-optional',
      'boost-regex',
      'boost-range',
      'boost-filesystem',
      'boost-container',
      'boost-algorithm',
      'boost-program-options',
      'boost-locale',
      'boost-iostreams',
      'boost-spirit',
      'boost-property-tree',
      'boost-log',
      'boost-uuid',
      'range-v3'
    )
    $packages = $packages.ForEach({ "${_}:${env:PLATFORM}-windows" })
# Build dependencies
- ps: |
    if ( $archive_incomplete -or ($env:BUILD -and "$env:Build" -eq "dependency-zip") ) {
      Write-Output "Install / update dependencies.`n-- Update vcpkg ..."
      pushd C:\Tools\vcpkg; git pull --quiet
      if ( $(vcpkg upgrade) -match "^Warning: Different source.*for vcpkg" ) {
        Write-Output '-- Rebuilding vcpkg...'
        .\bootstrap-vcpkg.bat 1>$null
        vcpkg integrate install 1>$null
        Write-Output '-- Rebuilding vcpkg... done'
      }
      if ( "$env:DEPENDENCIES" -eq "FREEZE" ) {
        Write-Output '-- Using frozen dependency versions.'
        git checkout $env:FREEZE_SHA1 --quiet
        git show --summary
      } else { Write-Output '-- Using dependencies from vcpkg HEAD.'}
      #if ( "$env:CONFIGURATION" -eq "Release") {
      #  Write-Output '-- Only build Release configuration'
      #  $triplet_build = 'set(VCPKG_BUILD_TYPE release)'
      #} else {
      #  Write-Output '-- Only build Debug configuration'
      #  $triplet_build = 'set(VCPKG_BUILD_TYPE debug)'
      #}
      #$triplet_file = ".\triplets\${env:PLATFORM}-windows.cmake"
      #$triplet_build | Out-File ${triplet_file} -Encoding ascii -Append
      popd
    }
# Display cache state
- vcpkg list
- ps: |
    if ( $archive_incomplete -or ($env:BUILD -and "$env:Build" -eq "dependency-zip") ) {
      $archive_incomplete = $false
      vcpkg update
      if (!($(vcpkg upgrade) -match "^All installed packages are up-to-date")) {
        vcpkg upgrade --no-dry-run
      }
      foreach ($item in $packages) {
        if ( (Get-Date) -lt $time_limit ) {
          vcpkg install $item
          Write-Output "Time remaining: $($time_limit - (Get-Date))"
        } else { $archive_incomplete = $true; break }
      }
      if ( $archive_incomplete ) { Exit-AppveyorBuild }
    }

before_build:
- ps: cd ${env:APPVEYOR_BUILD_FOLDER}
# Create or fake a NuGet package
- ps: |
    if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
      vcpkg export ${packages} --nuget --nuget-id=ThirdParty --nuget-version=${env:NUGET_version}
      $(nuget) | Select-Object -First 1 # display version
      nuget install ThirdParty -Source C:\Tools\vcpkg -OutputDirectory ${env:APPVEYOR_BUILD_FOLDER}\packages
    } else {
      $dir = "${env:APPVEYOR_BUILD_FOLDER}\packages\thirdparty.${env:NUGET_version}"
      mkdir "${dir}\build\native" | pushd
      '<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />' > thirdparty.targets
      popd
      mkdir "${dir}\installed\${env:PLATFORM}-windows" | pushd
      cmd /c mklink /j "tools" "C:\Tools\vcpkg\installed\${env:PLATFORM}-windows\tools"
      popd
    }

build_script:
- >-
  MSBuild
  -nologo
  -verbosity:minimal
  -p:Configuration="%CONFIGURATION%"
  -p:Platform="%PLATFORM%"
  -logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"

after_build:
# Collect files for distribution archive
- ps: |
    cd ${env:APPVEYOR_BUILD_FOLDER}
    if ( "${env:PLATFORM}" -eq "x64") {
      $dir = "${pwd}\x64\${env:CONFIGURATION}"
    } else {
      $dir = "${pwd}\${env:CONFIGURATION}"
    }
    mkdir .\archive\OpenCppCoverage *>$null
    Copy-Item @(
      "OpenCppCoverage.exe",
      "boost_*.dll",
      'bz2*.dll',         # bz2[d].dll
      'CppCoverage.dll',
      'Exporter.dll',
      'FileFilter.dll',
      'msdia140.dll',
      'libbz2*.dll',      # libbz2[d].dll
      'libctemplate.dll',
      'libprotobuf*.dll', # libprotobuf[d].dll
      'libctemplate.dll',
      'lzma.dll',
      'Tools.dll',
      'zlib*1.dll',       # zlib[d]1.dll
      'zstd*.dll'         # zstd[d].dll
    ).ForEach({ "${dir}\$_" }) -Destination .\archive\OpenCppCoverage
    Copy-Item "${dir}\Template" .\archive\OpenCppCoverage -Recurse
    $OpenCppCoverage_exe = "${pwd}\archive\OpenCppCoverage\OpenCppCoverage.exe"
    Write-Output '-- Create archive...'
    pushd .\archive
    7z u -bso0 -- "${env:redist_name}.zip" OpenCppCoverage
    Write-Output '-- Create archive... done'
    popd

before_test:
- ps: |
    Write-Output '-- Test configuration'
    $gtest_list = @(
      'ToolsTest.exe',
      'FileFilterTest.exe',
      'CppCoverageTest.exe'
      'ExporterTest.exe'
      'OpenCppCoverageTest.exe'
    )
    $mstest_list = @(
      'DefaultTest.dll'
    )
    if ( "${env:PLATFORM}" -eq "x64" ) {
      $gtest_path_list = $gtest_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:PLATFORM}\${env:CONFIGURATION}\${_}"
      })
      $mstest_path_list = $mstest_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:PLATFORM}\${env:CONFIGURATION}\${_}"
      })
    } else {
      $gtest_path_list = $gtest_path_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:CONFIGURATION}\${_}"
      })
      $mstest_path_list = $mstest_path.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:CONFIGURATION}\${_}"
      })
    }
    if ("$env:APPVEYOR_BUILD_WORKER_IMAGE" -match "Visual Studio 2017") {
      $extensions = "C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\Extensions\"
    } else {
      Error 'Only testing on VS 2017 supported!' `
        -Details 'Add path to Google Test Adapter in AppVeyor.yml ($extensions).'
    }
    $TestAdapterPath = (
      Get-ChildItem -Path ${extensions} -Recurse |
      Where-Object { $_.Name -eq 'GoogleTestAdapter.TestAdapter.dll' } |
      Select-Object -First 1
    ).DirectoryName
    if (! $TestAdapterPath) { Error "Can't find GoogleTestAdapter." }
    $runsettings = "${env:APPVEYOR_BUILD_FOLDER}\GoogleTestAdapter.runsettings"

test_script:
- ps: |
    Write-Output '-- Run tests...'
    foreach ($exec in $gtest_path_list) {
      VSTest.Console "${exec}" /TestAdapterPath:"${TestAdapterPath}" /Settings:"${runsettings}" /logger:Appveyor
    }
    foreach ($exec in $mstest_path_list) {
      VSTest.Console "${exec}" /logger:Appveyor
    }
    Write-Output '-- Run tests... done'
- ps: |
    Write-Output '-- Test for missing DLLs...'
    $result = $(Start-Process "${OpenCppCoverage_exe}" -PassThru)
    Start-Sleep -Seconds 2 # Allow for Event manager to update
    $( $item = Get-WinEvent -FilterHashtable @{LogName='System'
        ProviderName='Application Popup'; StartTime=(Get-Date).AddMinutes(-1)
      } -MaxEvents 1
    ) *>$null
    if ($item) {
      Error 'Execution error' -Details 'Failed to run:',
        ${OpenCppCoverage_exe}, $item.Message -NewLine
    }
    Write-Output '-- Test for missing DLLs... done'

after_test:
# Make NuGet package & zip available as artifact, only when being deployed.
- ps: |
    pushd "${env:APPVEYOR_BUILD_FOLDER}"
    if ( "$env:APPVEYOR_REPO_TAG" -eq "true" -and
         "$env:CONFIGURATION" -eq "Release" -and
         "$env:NUGET" -eq "on" -and "$env:DEPENDENCIES" -eq "FREEZE" ) {
      mv C:\Tools\vcpkg\*.nupkg .\
    }
    if ( "$env:CONFIGURATION" -eq "Release") {
      mv ".\archive\${env:redist_name}.zip" .\
    }
    Write-Output "-- NuGet packages: $((ls .\*.nupkg).Name)"
    Write-Output "-- Zip archives: $((ls .\*.zip).Name)"
    popd

artifacts:
- name: OpenCppCoverage
  path: "%redist_name%.zip"
  type: zip
- name: Dependencies-%PLATFORM%-%NUGET_version%
  path: '*.nupkg'
  type: NuGetPackage

deploy:
- provider: GitHub
  description: ''
  auth_token:
    secure: RPBFZIxYFlcAhSb7iwr1gaBzXC3xaZSI3InJD4eSL8/pYi0YQEhll7qx5tb3xEib
  artifact: /.*\.nupkg|OpenCppCoverage.*\.zip/
  draft: true
  prerelease: true
  on:
    APPVEYOR_REPO_TAG: true
    configuration: Release
    NUGET: on
    DEPENDENCIES: FREEZE

- provider: GitHub
  tag: latest
  release: OpenCppCoverage - Unstable
  description: |
    Last successful build using the latest dependency versions.
    Moving release considered unstable.
  auth_token:
    secure: RPBFZIxYFlcAhSb7iwr1gaBzXC3xaZSI3InJD4eSL8/pYi0YQEhll7qx5tb3xEib
  artifact: /OpenCppCoverage.*HEAD\.zip/
  draft: true
  prerelease: true
  force_update: true
  on:
    branch: CI
    configuration: Release


on_success:
- cd %APPVEYOR_BUILD_FOLDER%
# Code coverage
- ps: |
    $command = "$OpenCppCoverage_exe --export_type=binary"
    $command += " --modules ${env:APPVEYOR_BUILD_FOLDER}"
    $command += " --sources ${env:APPVEYOR_BUILD_FOLDER}"
    Foreach ( $exec in $gtest_path_list ) {
      "$command -- $exec" | Invoke-Expression *>$null
    }
# Combine into a single report
- ps: |
    $combine = "$OpenCppCoverage_exe"
    $combine += $gtest_list.ForEach({ " --input_coverage ${_}" })
    $combine = $combine -replace 'Test\.exe', 'Test.cov'
    $combine += ' --export_type=cobertura:Coverage.xml'
    $combine | Invoke-Expression *>$null
# Install uploader for codecov.io
- ps: $(pip install codecov)
# Upload to codecov.io
- ps: $(python -m codecov -f Coverage.xml -X gcov)
