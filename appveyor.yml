##====---- appveyor.yml                                               ----====##
# CI for OpenCppCoverage.
# Nuget generation is just to be compatible with the default project files.
#

# fetch repository as a zip archive
shallow_clone: true

skip_branch_with_pr: true
skip_commits:
  files:
  - .github/
  - .gitignore
  - BuildThirdPartyDependencies.bat
  - CreateRelease.bat
  - LICENSE.txt
  - '**/*.md'
  - '**/*.filters'

cache:
- C:\Tools\vcpkg\vcpkg.exe

image:
- Visual Studio 2017

platform:
- x86
- x64

configuration:
- Release
- Debug

environment:
  matrix:
  - BUILD: dependency-zip
  - configuration: Release
  - configuration: Debug
  #- BUILD: dependency-zip
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  #- configuration: Release
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  #- configuration: Debug
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  global:
    APPVEYOR_SAVE_CACHE_ON_ERROR: true
    TOOLCHAIN_FILE: 'C:/Tools/vcpkg/scripts/buildsystems/vcpkg.cmake'
    FREEZE_SHA1: 4c6950adcb4a442e24b43af6643720c41a80fdc8
    NUGET_version: 1.2.0

for:
-
  matrix:
    only:
    - BUILD: dependency-zip
  before_build:
  - ps: Write-Warning 'Skipping before_build.'
  build_script:
  - ps: Write-Warning 'Skipping build_script.'
  before_test:
  - ps: Write-Warning 'Skipping before_test.'
  test_script:
  - ps: Write-Warning 'Skipping test_script.'
  on_success:
  - ps: |
      Write-Output "Creating ${dependency_zip_name}"
      7z u -bso0 -- ${dependency_zip_name} "C:\Tools\vcpkg\installed"
      if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
        7z u -bso0 -- ${dependency_zip_name} "C:\Tools\vcpkg\packages"
      }
      Push-AppveyorArtifact ${dependency_zip_name}
-
  matrix:
   only:
   - configuration: Release
     NUGET: on
  artifacts:
  - path: '*.nupkg'
    name: Dependencies-%PLATFORM%-%NUGET_version%
    type: NuGetPackage
  deploy:
  - provider: GitHub
    description: ''
    auth_token:
      secure: RPBFZIxYFlcAhSb7iwr1gaBzXC3xaZSI3InJD4eSL8/pYi0YQEhll7qx5tb3xEib
    artifact: /.*\.nupkg/
    draft: true
    prerelease: true
    on:
      APPVEYOR_REPO_TAG: true


install:
# Packages to install from vcpkg:
- ps: |
    $packages = @(
      'poco',
      'protobuf',
      'gtest',
      'ctemplate',
      'boost-optional',
      'boost-filesystem',
      'boost-algorithm',
      'boost-container',
      'boost-program-options',
      'boost-regex',
      'boost-range',
      'boost-log',
      'boost-property-tree',
      'boost-spirit',
      'boost-uuid',
      'boost-locale',
      'boost-iostreams',
      'range-v3'
    )
    $packages = $packages.ForEach({ "${_}:${env:PLATFORM}-windows" })
# Shared Dependency Cache (as Artifact)
- ps: |
    $dependency_zip_name = "dependency_${env:PLATFORM}"
    if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
      $dependency_zip_name += '_nuget'
    }
    if ( -not $env:DEPENDENCIES -or "${env:DEPENDENCIES}" -ne "FREEZE" ) {
      $dependency_zip_name += '_HEAD'
    }
    $dependency_zip_name += ".zip"
    Write-Output "Artifact: ${dependency_zip_name}"
- ps: |
    if ( -not $Flush_Artifact ) {
      Write-Output "Try downloading artifact ..."
      $api_url = 'https://ci.appveyor.com/api'
      $account = "${env:APPVEYOR_ACCOUNT_NAME}"
      $project = "${env:APPVEYOR_PROJECT_SLUG}"
      $headers = @{ "Authorization" = "Bearer ${api_token}" }
      $url_project  = "${api_url}/projects/${account}/${project}"
      $url_zip_file = "${url_project}/artifacts/${dependency_zip_name}"
      $(Invoke-RestMethod -Uri "${url_zip_file}" `
        -Method Get -DisableKeepAlive -TimeoutSec 300 `
        -Headers ${headers} `
        -ContentType 'application/zip, application/octet-stream' `
        -OutFile $dependency_zip_name
      )
      if ([IO.File]::Exists("${pwd}\${dependency_zip_name}")) {
        Write-Output "-- Download done`n-- Extracting ..."
        7z x -y -bso0 $dependency_zip_name -o"C:\Tools\vcpkg"
        Write-Output '-- Extracting ... done'
      } elseif ( -not $env:BUILD -or "${env:Build}" -ne "dependency-zip" ) {
        Write-Error 'Artifact not found.'
      } elseif ( "${env:CONFIGURATION}" -eq "Debug" ) {
        Write-Error 'Artifact not found. Run release build before debug.'
      } else {
        Write-Output 'Artifact not found. Rebuilding all dependencies.'
      }
    }
# Build dependencies
- ps: |
    if ( $env:BUILD -and "$env:Build" -eq "dependency-zip" ) {
      Write-Output "Install / update dependencies.`n-- Update vcpkg ..."
      pushd C:\Tools\vcpkg; git pull --quiet
      if ( $(vcpkg upgrade) -match "^Warning: Different source.*for vcpkg" ) {
        Write-Output '-- Rebuilding vcpkg...'
        .\bootstrap-vcpkg.bat 1>$null
        vcpkg integrate install 1>$null
        Write-Output '-- Rebuilding vcpkg... done'
      }
      if ( "$env:DEPENDENCIES" -eq "FREEZE" ) {
        Write-Output '-- Using frozen dependency versions.'
        git checkout $env:FREEZE_SHA1 --quiet
        git show --summary
      } else { Write-Output '-- Using dependencies from vcpkg HEAD.'}
      if ( "$env:CONFIGURATION" -eq "Release") {
        Write-Output '-- Only build Release configuration'
        $triplet_build = 'set(VCPKG_BUILD_TYPE release)'
      } else {
        Write-Output '-- Only build Debug configuration'
        $triplet_build = 'set(VCPKG_BUILD_TYPE debug)'
      }
      $triplet_file = ".\triplets\${env:PLATFORM}-windows.cmake"
      $triplet_build | Out-File ${triplet_file} -Encoding ascii -Append
      popd
    }
# Display cache state
- vcpkg list
- ps: |
    if ( $env:BUILD -and "$env:Build" -eq "dependency-zip" ) {
      vcpkg update
      if (!($(vcpkg upgrade) -match "^All installed packages are up-to-date")) {
        vcpkg upgrade --no-dry-run
      }
      foreach ($item in $packages) {
        vcpkg install $item
      }
    }

before_build:
- ps: cd ${env:APPVEYOR_BUILD_FOLDER}
# Create or fake a NuGet package
- ps: |
    if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
      vcpkg export ${packages} --nuget --nuget-id=ThirdParty --nuget-version=${env:NUGET_version}
      $(nuget) | Select-Object -First 1 # display version
      nuget install ThirdParty -Source C:\Tools\vcpkg -OutputDirectory ${env:APPVEYOR_BUILD_FOLDER}\packages
      mv C:\Tools\vcpkg\*.nupkg ${env:APPVEYOR_BUILD_FOLDER}
    } else {
      $dir = "${env:APPVEYOR_BUILD_FOLDER}\packages\thirdparty.${env:NUGET_version}"
      mkdir "${dir}\build\native" | pushd
      '<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />' > thirdparty.targets
      popd
      mkdir "${dir}\installed\${env:PLATFORM}-windows" | pushd
      cmd /c mklink /j "tools" "C:\Tools\vcpkg\installed\${env:PLATFORM}-windows\tools"
      popd
    }

build_script:
- >-
  MSBuild
  -nologo
  -verbosity:minimal
  -p:Configuration="%CONFIGURATION%"
  -p:Platform="%PLATFORM%"
  -logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"

before_test:
- ps: |
    Write-Output '-- Test configuration'
    $gtest_list = @(
      'ToolsTest.exe',
      'FileFilterTest.exe',
      'CppCoverageTest.exe'
      'ExporterTest.exe'
      'OpenCppCoverageTest.exe'
    )
    $mstest_list = @(
      'DefaultTest.dll'
    )
    if ( "${env:PLATFORM}" -eq "x64" ) {
      $gtest_path_list = $gtest_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:PLATFORM}\${env:CONFIGURATION}\${_}"
      })
      $mstest_path_list = $mstest_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:PLATFORM}\${env:CONFIGURATION}\${_}"
      })
      $OpenCppCoverage_exe = "${env:APPVEYOR_BUILD_FOLDER}\${env:PLATFORM}\${env:CONFIGURATION}\OpenCppCoverage.exe"
    } else {
      $gtest_path_list = $gtest_path_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:CONFIGURATION}\${_}"
      })
      $mstest_path_list = $mstest_path.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:CONFIGURATION}\${_}"
      })
    }
    if ("$env:APPVEYOR_BUILD_WORKER_IMAGE" -match "Visual Studio 2017") {
      $extensions = "C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\Extensions\"
    }
    $TestAdapterPath = (
      Get-ChildItem -Path ${extensions} -Recurse |
      Where-Object { $_.Name -eq 'GoogleTestAdapter.TestAdapter.dll' } |
      Select-Object -First 1
    ).DirectoryName
    if (! $TestAdapterPath) { Write-Error "Can't find GoogleTestAdapter." }
    $runsettings = "${env:APPVEYOR_BUILD_FOLDER}\GoogleTestAdapter.runsettings"

test_script:
- ps: |
    Write-Output '-- Run tests...'
    foreach ($exec in $gtest_path_list) {
      VSTest.Console "${exec}" /TestAdapterPath:"${TestAdapterPath}" /Settings:"${runsettings}" /logger:Appveyor
    }
    foreach ($exec in $mstest_path_list) {
      VSTest.Console "${exec}" /logger:Appveyor
    }
    Write-Output '-- Run tests... done'

on_success:
- cd %APPVEYOR_BUILD_FOLDER%
# Code coverage
- ps: |
    $command = "$OpenCppCoverage_exe --export_type=binary"
    $command += " --modules ${env:APPVEYOR_BUILD_FOLDER}"
    $command += " --sources ${env:APPVEYOR_BUILD_FOLDER}"
    Foreach ( $exec in $gtest_path_list ) {
      "$command -- $exec" | Invoke-Expression *>$null
    }
# Combine into a single report
- ps: |
    $combine = "$OpenCppCoverage_exe"
    $combine += $gtest_list.ForEach({ " --input_coverage ${_}" })
    $combine = $combine -replace 'Test\.exe', 'Test.cov'
    $combine += ' --export_type=cobertura:Coverage.xml'
    $combine | Invoke-Expression *>$null
# Install uploader for codecov.io
- ps: $(pip install codecov)
# Upload to codecov.io
- ps: $(python -m codecov -f Coverage.xml -X gcov)
