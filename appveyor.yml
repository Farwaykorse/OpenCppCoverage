##====---- appveyor.yml                                               ----====##
# CI for OpenCppCoverage.
#

# fetch repository as a zip archive
shallow_clone: true

skip_branch_with_pr: true
skip_commits:
  files:
  - .github/
  - .gitignore
  - BuildThirdPartyDependencies.bat
  - CreateRelease.bat
  - LICENSE.txt
  - '**/*.md'
  - '**/*.filters'

cache:
- C:\Tools\vcpkg\vcpkg.exe

image:
- Visual Studio 2017

platform:
- x86
- x64

environment:
  matrix:
  - BUILD: dependency-zip
  - configuration: Debug
  - configuration: Release
  #- BUILD: dependency-zip
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  #- configuration: Debug
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  #- configuration: Release
  #  DEPENDENCIES: FREEZE
  #  NUGET: on
  global:
    APPVEYOR_SAVE_CACHE_ON_ERROR: true
    TOOLCHAIN_FILE: 'C:/Tools/vcpkg/scripts/buildsystems/vcpkg.cmake'
    FREEZE_SHA1: 4c6950adcb4a442e24b43af6643720c41a80fdc8
    NUGET_version: 1.2.0

for:
-
  matrix:
    only:
    - BUILD: dependency-zip
  before_build:
  - ps: Write-Warning 'Skipping before_build.'
  build_script:
  - ps: Write-Warning 'Skipping build_script.'
  after_build:
  - ps: Write-Warning 'Skipping after_build.'
  before_test:
  - ps: Write-Warning 'Skipping before_test.'
  test_script:
  - ps: Write-Warning 'Skipping test_script.'
  on_success:
  - ps: |
      Write-Output "Creating ${dependency_zip_name}"
      7z u -bso0 -- ${dependency_zip_name} "C:\Tools\vcpkg\installed"
      if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
        7z u -bso0 -- ${dependency_zip_name} "C:\Tools\vcpkg\packages"
      }
      if ( $archive_incomplete ) {
        New-Item archive_incomplete
        7z u -bso0 -- ${dependency_zip_name} ".\archive_incomplete"
        Warning -Message 'Dependency archive is incomplete.' -Details `
          'Not all dependencies have been build. Expect increased build times.',
          'The archive will be completed during the next build.' -NewLine
      }
      Push-AppveyorArtifact ${dependency_zip_name}
-
  matrix:
   only:
   - configuration: Release
     NUGET: on
  artifacts:
  - path: '*.nupkg'
    name: Dependencies-%PLATFORM%-%NUGET_version%
    type: NuGetPackage
  deploy:
  - provider: GitHub
    description: ''
    auth_token:
      secure: RPBFZIxYFlcAhSb7iwr1gaBzXC3xaZSI3InJD4eSL8/pYi0YQEhll7qx5tb3xEib
    artifact: /.*\.nupkg/
    draft: true
    prerelease: true
    on:
      APPVEYOR_REPO_TAG: true

init:
# Collect AppVeyor Artifact of previously compiled dependencies.
- ps: |
    $time_limit = (Get-Date) + $(New-TimeSpan -Minutes 45)
- ps: |
    $dependency_zip_name = "dependency_${env:PLATFORM}"
    if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
      $dependency_zip_name += '_nuget'
    }
    if ( $env:DEPENDENCIES -and "${env:DEPENDENCIES}" -eq "FREEZE" ) {
      $dependency_zip_name += "_v${env:NUGET_version}"
      $jobname = 'Environment%3A%20BUILD%3Ddependency-zip%2C%20DEPENDENCIES%3DFREEZE%2C%20NUGET%3Don'
    } else {
      $dependency_zip_name += '_HEAD'
      $jobname = 'Environment%3A%20BUILD%3Ddependency-zip'
    }
    $dependency_zip_name += ".zip"
    Write-Output "Artifact name: ${dependency_zip_name}"
    Write-Output "JobID:         ${env:APPVEYOR_JOB_ID}"
- ps: |
    function Send-Output {
      param([parameter(Mandatory=$true,Position=0,ValueFromPipeline=$true)]
        [alias('m')][String]$Message,
        [parameter(Position=1,ValueFromPipeline=$true,ValueFromRemainingArguments=$true)]
        [alias('d')][String[]]$Details,[alias('hide','h')][Switch]$HideDetails,
        [alias('n','NewLine')][Switch]$SeparateLines,
        [Switch]$Error,[Switch]$Warning,[Switch]$Info
      )
      if ($Details) {
        $Details = $(
          if ($SeparateLines) { $Details -join "`n" } else { $Details -join ' ' }
        ) -replace "`n [^\s]", "`n"
      }
      if ($env:APPVEYOR) { 
        $AppVeyor = 'Add-AppveyorMessage ${Message} -Category '
        if       ($Error)   { $AppVeyor += 'Error'
        } elseif ($Warning) { $AppVeyor += 'Warning'
        } else              { $AppVeyor += 'Information' }
        if ($Details) { $AppVeyor += ' -Details $Details' }
        Invoke-Expression -Command $AppVeyor
      }
      if ($Error) {
        Write-Host $Message -ForegroundColor White -BackgroundColor Red
        if ($Details -and -not $HideDetails) { Write-Host $Details -ForegroundColor Red }
        if ($env:APPVEYOR -and -not $ContinueOnError) { $Host.SetShouldExit(1) }
      } elseif ($Warning) {
        if ($Details -and -not $HideDetails) { $Message += "`n${Details}" }
        Write-Warning $Message
      } else {
        if ($Details -and -not $HideDetails) {
          $Message += "`n$("-- $Details" -replace "`n", "`n-- ")"
        }
        Write-Output "INFO: $Message"
      }
    } # /function Send-Output
    function Error   { Send-Output @Args -Error }
    function Warning { Send-Output @Args -Warning }
    function Info    { Send-Output @Args -Info }
- ps: |
    Write-Output 'Collect previously compiled dependencies'
    $api_url = 'https://ci.appveyor.com/api'
    $url_project = "${api_url}/projects/${env:APPVEYOR_ACCOUNT_NAME}/${env:APPVEYOR_PROJECT_SLUG}"
    if ( -not $env:api_token ) {
      Error 'AppVeyor API-token not found!' `
        -Details 'Set the environment variable "api_token" ',
        'in the AppVeyor project settings. (ðŸ”’ With variable encription.)'
    }
    if ( $env:BUILD -and "${env:Build}" -eq "dependency-zip" ) {
      Write-Output '-- Get dependencies from previous build:'
      $url_zip_file = "${url_project}/artifacts/${dependency_zip_name}"
      $url_zip_file += "?all=true&job=${jobname}"
    } else {
      # Get dependency-zip from current build
      $url_branch = "${url_project}/branch/${env:APPVEYOR_REPO_BRANCH}"
      $($branchbuilds = Invoke-RestMethod "${url_branch}" `
        -Method Get -DisableKeepAlive -TimeoutSec 300 `
        -Headers @{ "Authorization" = "Bearer ${env:api_token}" } `
        -ContentType 'application/json'
        $success = $?
      )
      if ( $success ) {
        if ( $branchbuilds.build.buildNumber -ne $env:APPVEYOR_BUILD_NUMBER) {
          Warning 'API change: not returning current build in progress!' `
            -Details "Expected build: ${env:APPVEYOR_BUILD_NUMBER}",
            "Received build: $($branchbuilds.build.buildNumber)" -NewLine
        }
        $jobId = ($branchbuilds.build.jobs | where {
          $_.name -Match 'Build=dependency-zip' -and
          $_.artifactsCount -ge 1 -and
          -not ($env:DEPENDENCIES -match 'FREEZE' -xor $_.name -match 'FREEZE') -and
          -not ($env:NUGET -match 'on' -xor $_.name -match 'NUGET=on')
        }).jobId
        if ( $jobId ) {
          $url_zip_file = "${api_url}/buildjobs/${jobId}/artifacts/${dependency_zip_name}"
          Write-Output '-- Get dependencies from current build:'
        } else {
          Warning 'Cannot find artifact for current configuration.'
        }
      }
    }
    Write-Output "-- Downloading ...`n${url_zip_file}"
    $(Invoke-RestMethod "${url_zip_file}" `
      -Method Get -DisableKeepAlive -TimeoutSec 300 `
      -Headers @{ "Authorization" = "Bearer ${env:api_token}" } `
      -ContentType 'application/zip, application/octet-stream' `
      -OutFile $dependency_zip_name
      $success = $?
    )
    if ( $success ) {
      Write-Output '-- Downloading ... done'
      if ([IO.File]::Exists("${pwd}\${dependency_zip_name}")) {
        Write-Output '-- Extracting ...'
        7z x -y -bso0 $dependency_zip_name -o"C:\Tools\vcpkg"
        Write-Output '-- Extracting ... done'
        if ( Test-Path 'C:\Tools\vcpkg\archive_incomplete' ) {
          $archive_incomplete = $true
          Warning 'Dependency archive is incomplete. Increased build time.'
          rm 'C:\Tools\vcpkg\archive_incomplete'
          7z d -bso0 -- ${dependency_zip_name} "archive_incomplete"
        }
      } else { Error "${pwd}\${dependency_zip_name} does not exist!" }
    } else {
      Info 'Reset previously compiled dependencies from artifact - failed' `
        -Details 'Rebuilding all dependencies'
    }
    Write-Output "${pwd}\${dependency_zip_name}"

install:
# Packages to install from vcpkg:
- ps: |
    $packages = @( # Sorted to build in separate sets.
      'poco',
      'protobuf',
      'gtest',
      'ctemplate',
      'boost-optional',
      'boost-regex',
      'boost-range',
      'boost-filesystem',
      'boost-container',
      'boost-algorithm',
      'boost-program-options',
      'boost-locale',
      'boost-iostreams',
      'boost-spirit',
      'boost-property-tree',
      'boost-log',
      'boost-uuid',
      'range-v3'
    )
    $packages = $packages.ForEach({ "${_}:${env:PLATFORM}-windows" })
# Build dependencies
- ps: |
    if ( $archive_incomplete -or ($env:BUILD -and "$env:Build" -eq "dependency-zip") ) {
      Write-Output "Install / update dependencies.`n-- Update vcpkg ..."
      pushd C:\Tools\vcpkg; git pull --quiet
      if ( $(vcpkg upgrade) -match "^Warning: Different source.*for vcpkg" ) {
        Write-Output '-- Rebuilding vcpkg...'
        .\bootstrap-vcpkg.bat 1>$null
        vcpkg integrate install 1>$null
        Write-Output '-- Rebuilding vcpkg... done'
      }
      if ( "$env:DEPENDENCIES" -eq "FREEZE" ) {
        Write-Output '-- Using frozen dependency versions.'
        git checkout $env:FREEZE_SHA1 --quiet
        git show --summary
      } else { Write-Output '-- Using dependencies from vcpkg HEAD.'}
      if ( "$env:CONFIGURATION" -eq "Release") {
        Write-Output '-- Only build Release configuration'
        $triplet_build = 'set(VCPKG_BUILD_TYPE release)'
      } else {
        Write-Output '-- Only build Debug configuration'
        $triplet_build = 'set(VCPKG_BUILD_TYPE debug)'
      }
      $triplet_file = ".\triplets\${env:PLATFORM}-windows.cmake"
      $triplet_build | Out-File ${triplet_file} -Encoding ascii -Append
      popd
    }
# Display cache state
- vcpkg list
- ps: |
    if ( $archive_incomplete -or ($env:BUILD -and "$env:Build" -eq "dependency-zip") ) {
      $archive_incomplete = $false
      vcpkg update
      if (!($(vcpkg upgrade) -match "^All installed packages are up-to-date")) {
        vcpkg upgrade --no-dry-run
      }
      foreach ($item in $packages) {
        if ( (Get-Date) -lt $time_limit ) {
          vcpkg install $item
          Write-Output "Time remaining: $($time_limit - (Get-Date))"
        } else { $archive_incomplete = $true; break }
      }
      if ( $archive_incomplete ) { Exit-AppveyorBuild }
    }

before_build:
- ps: cd ${env:APPVEYOR_BUILD_FOLDER}
# Create or fake a NuGet package
- ps: |
    if ( $env:NUGET -and "$env:NUGET" -eq "on" ) {
      vcpkg export ${packages} --nuget --nuget-id=ThirdParty --nuget-version=${env:NUGET_version}
      $(nuget) | Select-Object -First 1 # display version
      nuget install ThirdParty -Source C:\Tools\vcpkg -OutputDirectory ${env:APPVEYOR_BUILD_FOLDER}\packages
      mv C:\Tools\vcpkg\*.nupkg ${env:APPVEYOR_BUILD_FOLDER}
    } else {
      $dir = "${env:APPVEYOR_BUILD_FOLDER}\packages\thirdparty.${env:NUGET_version}"
      mkdir "${dir}\build\native" | pushd
      '<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />' > thirdparty.targets
      popd
      mkdir "${dir}\installed\${env:PLATFORM}-windows" | pushd
      cmd /c mklink /j "tools" "C:\Tools\vcpkg\installed\${env:PLATFORM}-windows\tools"
      popd
    }

build_script:
- >-
  MSBuild
  -nologo
  -verbosity:minimal
  -p:Configuration="%CONFIGURATION%"
  -p:Platform="%PLATFORM%"
  -logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"

after_build:
# Collect files for distribution archive
- ps: |
    pushd ${env:APPVEYOR_BUILD_FOLDER}
    if ( "${env:PLATFORM}" -eq "x64") {
      $dir = "${pwd}\x64\${env:CONFIGURATION}"
    } else {
      $dir = "${pwd}\${env:CONFIGURATION}"
    }
    ls $dir
    mkdir .\program *>$null
    Copy-Item @(
      "OpenCppCoverage.exe",
      "boost_*.dll",
      'bz2*.dll',         # bz2[d].dll
      'CppCoverage.dll',
      'Exporter.dll',
      'FileFilter.dll',
      'msdia140.dll',
      'libbz2*.dll',      # libbz2[d].dll
      'libctemplate.dll',
      'libprotobuf*.dll', # libprotobuf[d].dll
      'libctemplate.dll',
      'lzma.dll',
      'Tools.dll',
      'zlib*1.dll',       # zlib[d]1.dll
      'zstd*.dll'         # zstd[d].dll
    ).ForEach({ "${dir}\$_" }) -Destination .\program
    Copy-Item "${dir}\Template" .\program -Recurse
    $OpenCppCoverage_exe = "${pwd}\program\OpenCppCoverage.exe"
    popd

before_test:
- ps: |
    Write-Output '-- Test configuration'
    $gtest_list = @(
      'ToolsTest.exe',
      'FileFilterTest.exe',
      'CppCoverageTest.exe'
      'ExporterTest.exe'
      'OpenCppCoverageTest.exe'
    )
    $mstest_list = @(
      'DefaultTest.dll'
    )
    if ( "${env:PLATFORM}" -eq "x64" ) {
      $gtest_path_list = $gtest_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:PLATFORM}\${env:CONFIGURATION}\${_}"
      })
      $mstest_path_list = $mstest_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:PLATFORM}\${env:CONFIGURATION}\${_}"
      })
    } else {
      $gtest_path_list = $gtest_path_list.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:CONFIGURATION}\${_}"
      })
      $mstest_path_list = $mstest_path.ForEach({
        "${env:APPVEYOR_BUILD_FOLDER}\${env:CONFIGURATION}\${_}"
      })
    }
    if ("$env:APPVEYOR_BUILD_WORKER_IMAGE" -match "Visual Studio 2017") {
      $extensions = "C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\Extensions\"
    } else {
      Error 'Only testing on VS 2017 supported!' `
        -Details 'Add path to Google Test Adapter in AppVeyor.yml ($extensions).'
    }
    $TestAdapterPath = (
      Get-ChildItem -Path ${extensions} -Recurse |
      Where-Object { $_.Name -eq 'GoogleTestAdapter.TestAdapter.dll' } |
      Select-Object -First 1
    ).DirectoryName
    if (! $TestAdapterPath) { Error "Can't find GoogleTestAdapter." }
    $runsettings = "${env:APPVEYOR_BUILD_FOLDER}\GoogleTestAdapter.runsettings"

test_script:
- ps: |
    Write-Output '-- Run tests...'
    foreach ($exec in $gtest_path_list) {
      VSTest.Console "${exec}" /TestAdapterPath:"${TestAdapterPath}" /Settings:"${runsettings}" /logger:Appveyor
    }
    foreach ($exec in $mstest_path_list) {
      VSTest.Console "${exec}" /logger:Appveyor
    }
    Write-Output '-- Run tests... done'

on_success:
- cd %APPVEYOR_BUILD_FOLDER%
# Code coverage
- ps: |
    $command = "$OpenCppCoverage_exe --export_type=binary"
    $command += " --modules ${env:APPVEYOR_BUILD_FOLDER}"
    $command += " --sources ${env:APPVEYOR_BUILD_FOLDER}"
    Foreach ( $exec in $gtest_path_list ) {
      "$command -- $exec" | Invoke-Expression *>$null
    }
# Combine into a single report
- ps: |
    $combine = "$OpenCppCoverage_exe"
    $combine += $gtest_list.ForEach({ " --input_coverage ${_}" })
    $combine = $combine -replace 'Test\.exe', 'Test.cov'
    $combine += ' --export_type=cobertura:Coverage.xml'
    $combine | Invoke-Expression *>$null
# Install uploader for codecov.io
- ps: $(pip install codecov)
# Upload to codecov.io
- ps: $(python -m codecov -f Coverage.xml -X gcov)
